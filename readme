## План разработки (MVP умного дома на Go) — по дням

Цель MVP: сервер на Go, который
- хранит реестр устройств и их текущее состояние,
- принимает телеметрию от устройств через MQTT,
- принимает команды от клиента по HTTP и отправляет их устройствам через MQTT,
- получает ack от устройств и обновляет статус команд,
- пушит события в UI через WebSocket или SSE.

Технологии (рекомендовано для MVP):
- Go (net/http, log/slog)
- MQTT broker: Mosquitto
- Хранилище: SQLite (позже можно PostgreSQL)
- Форматы: JSON
- События в UI: WebSocket или SSE

---

### День 1 — Каркас сервиса и инфраструктура запуска
**Задачи**
- Инициализировать Go-модуль и структуру проекта (`cmd/`, `internal/`)
- Добавить конфиг через env (адрес HTTP, уровни логов, таймауты)
- Настроить структурные логи (slog JSON)
- Поднять HTTP сервер + middleware (request-id, access log, recover)
- Добавить health endpoints: `GET /healthz`, `GET /readyz`, `GET /api/v1/version`
- Реализовать graceful shutdown по Ctrl+C / SIGTERM

**Готово, если**
- `go run ./cmd/server` стартует
- `curl localhost:8080/healthz` → `ok`
- Ctrl+C корректно завершает процесс с логом shutdown

---

### День 2 — База данных и миграции
**Задачи**
- Подключить SQLite (файл БД)
- Добавить миграции и таблицы:
  - `devices`
  - `device_state`
  - `commands`
- Написать слой хранения (репозитории) для:
  - CRUD `devices`
  - upsert `device_state`
  - create/update `commands`

**Готово, если**
- Миграции применяются при старте
- Репозитории покрыты базовыми тестами
- Можно создать устройство и прочитать его из БД

---

### День 3 — HTTP API: реестр устройств
**Задачи**
- Реализовать эндпоинты:
  - `GET /api/v1/devices`
  - `POST /api/v1/devices`
  - `GET /api/v1/devices/{id}`
  - `DELETE /api/v1/devices/{id}`
- Валидация входных данных
- Простейшая авторизация для MVP (например `X-API-Key`)

**Готово, если**
- Устройство можно добавить и увидеть в списке
- Устройство можно удалить
- Ошибки возвращаются в едином формате (хотя бы минимально)

---

### День 4 — MQTT: приём телеметрии и обновление состояния
**Задачи**
- Подключить MQTT-клиент
- Подписаться на топики телеметрии:
  - `home/1/device/{deviceId}/telemetry`
- Парсить JSON телеметрии, валидировать
- Обновлять `device_state` (последнее состояние)
- Публиковать внутреннее событие `device.state_changed` (внутренняя шина событий)

**Готово, если**
- Устройство публикует telemetry → сервер обновляет state в БД
- `GET /api/v1/devices/{id}/state` отдаёт актуальное состояние

---

### День 5 — Команды: HTTP → MQTT (отправка)
**Задачи**
- Реализовать:
  - `POST /api/v1/devices/{id}/commands`
  - `GET /api/v1/commands/{commandId}`
- Генерировать `commandId`
- Сохранять команду в БД (`pending`)
- Публиковать команду в MQTT:
  - `home/1/device/{deviceId}/command`

**Готово, если**
- Клиент создаёт команду → команда уходит в MQTT
- В БД команда появляется со статусом `pending`

---

### День 6 — Ack, статусы команд и таймауты
**Задачи**
- Подписка на ack топики:
  - `home/1/device/{deviceId}/ack`
- Обновлять `commands` в БД:
  - `acked` / `failed` + error
- Добавить воркер таймаутов:
  - если `pending` слишком долго → `timeout`
- Внутренние события:
  - `command.ack` / `command.timeout`

**Готово, если**
- При приходе ack статус команды обновляется
- Без ack команда уходит в `timeout`
- `GET /api/v1/commands/{id}` показывает актуальный статус

---

### День 7 — Пуш событий в UI (WebSocket или SSE)
**Задачи**
- Реализовать поток событий:
  - WebSocket: `GET /api/v1/ws`
  - или SSE: `GET /api/v1/events`
- Отправлять события:
  - `device.state_changed`
  - `command.ack`
  - `command.timeout`
- Минимальная фильтрация (например по `homeId`/устройствам)

**Готово, если**
- Клиент подписался и получает пуш-обновления без polling

---

### День 8 — Мини-автоматизации (опционально, если хватает времени)
**Задачи**
- Добавить сущность правила (минимум):
  - триггер: `state_changed` или `timer`
  - условие: простое сравнение значений
  - действие: отправка команды устройству
- Защита от циклов (минимальная):
  - не триггерить правило на событие, которое оно само породило (по correlationId/источнику)

**Готово, если**
- Пример: `motion=true` → включить свет на 2 минуты (таймер + команда)

---

### День 9 — Безопасность и эксплуатация (MVP-уровень)
**Задачи**
- Улучшить auth:
  - хотя бы один токен/ключ, конфигурируемый через env
- Разделить креды MQTT и ограничить доступ (ACL по топикам)
- Добавить rate limit (простое ограничение на команды/сек)
- Audit trail (минимально):
  - кто и когда отправил команду (если есть пользователь/ключ)

**Готово, если**
- “Случайный клиент” без ключа не управляет устройствами
- MQTT не принимает публикации куда попало

---

### День 10 — Тесты, Docker Compose, финальная полировка
**Задачи**
- Интеграционные тесты (по минимуму):
  - БД операции + обработка телеметрии/ack
- Docker Compose для локального запуска:
  - `mosquitto`
  - сервер
  - (опционально) простая UI-заглушка
- Обновить README:
  - как запустить
  - примеры запросов curl
  - формат MQTT сообщений
- Метрики/наблюдаемость (минимум):
  - счётчики обработанных сообщений/ошибок (можно просто в логах на MVP)

**Готово, если**
- `docker compose up` поднимает брокер + сервер
- Есть примеры “как проверить руками”

---

## Definition of Done (для MVP)
- Устройства добавляются через API и хранятся в БД
- Телеметрия через MQTT обновляет `device_state`
- Команды через HTTP публикуются в MQTT и получают ack/timeout
- UI может получать push-события (WS/SSE)
- Сервис корректно стартует/останавливается, есть healthchecks
